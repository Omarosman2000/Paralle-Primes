// There are 6 Steps in here! Step 1 to Step 5 worked successfully.// I have Demo-ed it to you on Thursday, 10/6/2022, in your Office Hours at 3:15PM //For Step 6, When I run ./countmaster 10 30 4 for the third time, that's were it prints a total number and it prints total 5.// It doesn't print the total from the first time when I run it. I have to run it at least 2 times in order for it to show.#include <stddef.h>#include <stdio.h>#include <sys/wait.h>#include <unistd.h>#include <stdlib.h>#include <sys/types.h>int main(int argc,char *argv[]){	char*arguments[4];			//make an array that can hold up to 4 strings	arguments[0]="./countprimes";		//the first string is the command name	arguments[1]=argv[1];			//the second and third strings are the start and end parameters	arguments[2]=argv[2];	arguments[3]=NULL;			//the last argument must be a null terminator	// initializing every variable used in this project starts here!	int NUMBER_OF_CALLS = atoi(argv[3]);	int pidarray[NUMBER_OF_CALLS];	int i = 0;	int k = 0;            int pid;	int total;	int status;	// This part here is the beginning of Step 6!	int min = atoi(arguments[1]);    	int max = atoi(arguments[2]);    	int inc = atoi(arguments[2])-atoi(arguments[1]);	int increment[NUMBER_OF_CALLS+1];    	int counter;    	increment[0] = atoi(arguments[1]);    	while(inc % NUMBER_OF_CALLS != 0)    	{            counter+=1;            inc-=1;    	}	// that is a foor loop for the increment for step 6!    	for(i=0; i< NUMBER_OF_CALLS; i++)    	{            if(i+1<NUMBER_OF_CALLS)            {                min += inc/NUMBER_OF_CALLS;                increment[i+1]= min;            }            else            {                increment[i+1]= min+counter+inc / NUMBER_OF_CALLS;                min += counter;            }    	}	// That is the end of the coding part for Step 6!	// Here starts the for loop for the execvp and also wher the forking begins!	for(i=0; i < NUMBER_OF_CALLS; i++)         {		pidarray[i] = fork();		// the child gets pid=0		// the parent gets pid!=0: parent gets pid of child		// now i have two processes running		printf("after fork %d\n", pid);		// have one process run execvp counterprimes		if(pidarray[i] == 0)		{		    char sstr[50];   //this is part of Step 6!                    char estr[50];   //this is part of step 6!		    // Here i am converting my numbers back to string using sprintf                    sprintf(sstr, "%d", increment[i]);                    sprintf(estr, "%d", increment[i+1]);                    arguments[1]=sstr;                    arguments[2]=estr;		    execvp("./countprimes", arguments);		}	 }	// Here starts another for loop for the waitpid!	for(k=0; k<NUMBER_OF_CALLS; k++)	{		//wait on child to finish using waitpid		//int status; // we are passing in the address		waitpid(pidarray[k], &status, 0);		total= total + WEXITSTATUS(status);			if(k == NUMBER_OF_CALLS - 1)			{				printf("total: %d \n", total);			}		//when i get here, two things:		// 1) child process is finished		// 2) status has a value:	}	while(1);	return;}